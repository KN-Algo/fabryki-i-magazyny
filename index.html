<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fabryki i Magazyny - Rysowanie Linii</title>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap');
    body {
      display: flex;
      flex-direction: column;
      margin: 0;
      font-family: 'JetBrains Mono', monospace;
    }
    h1 {
        margin: 3rem;
        text-align: center;
    }
    canvas {
      border: 1px solid black;
      justify-content: center;
      align-items: center;
    }
    div {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #sidebar {
      display: inline-block;
      margin-left: 20px;
    }
    #timer-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 10px;
      background-color: #e0e0e0; /* To paska */
    }
    
    #timer {
      width: 100%;
      height: 100%;
      background-color: #0074ba; /* Kolor postpu */
    }
    
    .button {
      margin-top: 10px;
      padding: 10px 20px;
      color: white;
      background-color: #0074ba;
      border: 1px solid #0074ba;
      cursor: pointer;
      border-radius: 25px;
      font-family: 'JetBrains Mono', monospace;
    }

    .button:hover {
      background-color: white;
      color: #0074ba;
      border: 1px solid #0074ba;
      transition: 0.4s all;
    }

    .button.active {
      background-color: #005f87;
      color: white;
      box-shadow: inset 0px 0px 5px rgba(0, 0, 0, 0.5); /* Wcinity wygld */
    }

    .button.active:hover {
      background-color: #0074ba;
      color: white;
      transition: all 0.4s;
    }
    
  </style>
</head>
<body>
  <div id="timer-container">
    <div id="timer"></div>
  </div>  
  <h1>Fabryki i Magazyny</h1>
  <div style="display: flex;">
    <canvas id="canvas" width="600" height="400"></canvas>
    <div id="sidebar">
      <h2>Magazyny: </h2>
      <h2>Fabryki: </h2>
      <h2>Magazyn na fabryce: </h2>
      <h2>Pozostae magazyny: <span id="remainingWarehouses">4</span></h2>
      <button id="eraserButton" class="button">Gumka</button>
      <button id="endGameButton" class="button">Zakocz gr</button>
      <a id="ranking-a" href=""><button class="button">Ranking</button></a>
    </div>
  </div>

  <script>

    let index = null;
    let username = null;

    // Inicjalizacja okna powitalnego
    window.onload = () => {
      const { value: formValues } = Swal.fire({
        title: 'Witaj w grze Fabryki i Magazyny!',
        html: `
          <div style="text-align: left; font-size: 14px; display: inline-block">
            <p>Twoim zadaniem jest poczenie fabryk z magazynami za pomoc linii. Kliknij na mapie, aby doda magazyn. Po dodaniu wszystkich magazyn贸w, zaznacz dowoln fabryk i pocz j z magazynami. Celem gry jest zminimalizowanie cakowitej dugoci tras. Im kr贸tsza trasa, tym lepiej!</p>
            <p>Ukocz zadanie, zanim pasek na g贸rze strony dobiegnie koca. Powodzenia!</p>
            <input id="swal-input1" class="swal2-input" placeholder="Podaj sw贸j nick" style="width: 90%; box-sizing: border-box;" required>
            <input id="swal-input2" class="swal2-input" placeholder="Podaj sw贸j numer indeksu" style="width: 90%; box-sizing: border-box;" required>
          </div>
        `,
        icon: 'info',
        confirmButtonText: 'Rozpocznij',
        showDenyButton: true,
        denyButtonColor: '#0074ba',
        denyButtonText: 'Ranking',
        footer: "Biorc udzia w grze, zgadzasz si na przetwarzanie swoich danych osobowych w celu ewentualnego przyznania nagrody.",
        focusConfirm: false,
        allowOutsideClick: false,
        allowEscapeKey: false,
        width: '600px',
        preDeny : () => {
          window.location.href = 'ranking.html';
        },
        preConfirm: () => {
          // Pobieramy dane u偶ytkownika z popupu
          username = document.getElementById('swal-input1').value;
          index = document.getElementById('swal-input2').value;

          if (!username || !index) {
            Swal.showValidationMessage('Wszystkie pola s wymagane!');
            return;
          }

          let regex = /^[0-9]{6}$/;
          if (!regex.test(index)) {
            Swal.showValidationMessage('Numer indeksu musi skada si z 6 cyfr!');
            return;
          }

          // Wysyamy dane u偶ytkownika do serwera
          let formData = new FormData();
          formData.append('username', username);
          formData.append('index', index);
          console.log(formData);
          return fetch('/backend/api/validateUser.php', {
            method: 'POST',
            body: formData
          })
          .then(response => {
            if (!response.ok) {
              throw new Error('Bd poczenia z serwerem! Spr贸buj ponownie.');
            } else {
              return response.json().then(data => {
                if (data.code === 400) {
                  throw new Error(data.error);
                }
              });
            }
          })
          .catch(error => {
            // Wywietlamy komunikat o bdzie w popupie bez jego zamykania
            Swal.showValidationMessage(`${error.message}`);
            return;
          });
        }
      }).then((result) => {
        document.getElementById('ranking-a').href = `ranking.html?username=${username}`;
        startTimer(180); // Uruchamiamy timer na 3 minuty
      });
    };
    
    
    let isEraserMode = false;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const remainingWarehousesSpan = document.getElementById('remainingWarehouses');
    const factories = [];
    const warehouses = [];
    let selectedStart = null;
    let lines = [];
    let remainingWarehouses = 4; // Liczba magazyn贸w do postawienia
    let totalLength = 0;
    let isCanvasLocked = false;
    let timeRemaining = null;
    const POINT_RADIUS = 5; // Standardowy rozmiar punkt贸w
    const HIGHLIGHT_RADIUS = 7; // Rozmiar punkt贸w po podwietleniu
    const CLICK_THRESHOLD = 10; // Maksymalna odlego w pikselach do wybrania punktu
    const GRID_SIZE = 20; // Rozmiar pojedynczego kwadratu siatki

    // Funkcja rysujca siatk
    function drawGrid() {
      ctx.strokeStyle = '#e0e0e0'; // Ustawienie koloru siatki na delikatn szaro
      for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function isOverFactory(x, y) {
      return factories.find(factory => {
        const dx = x - factory.x;
        const dy = y - factory.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance <= POINT_RADIUS; // Punkt znajduje si w obrbie fabryki
      });
    }
    

    // Przyciganie do siatki
    function snapToGrid(value) {
      return Math.round(value / GRID_SIZE) * GRID_SIZE;
    }

    // Losowe generowanie fabryk, przycigane do siatki
    function generateFactories(numFactories) {
      drawGrid();
      for (let i = 0; i < numFactories; i++) {
        let x = snapToGrid(Math.random() * canvas.width);
        let y = snapToGrid(Math.random() * canvas.height);
        const factory = { x, y };
        factories.push(factory);
        drawPoint(factory.x, factory.y, 'blue');
      }
      let returnVal = startAlgorithm();
      let EdgePoint = returnVal[0];
      let theBestWarehouseConfiguration = returnVal[1];
      EdgePoints.forEach((points, i) => {
        console.log(points);
        drawLine(points.p1, points.p2);
      });
      console.log('theBestWarehouseConfiguration = ${theBestWarehouseConfiguration}');
      console.log(theBestWarehouseConfiguration);
    }

    // Rysowanie punkt贸w fabryk/magazyn贸w
    function drawPoint(x, y, color, highlight = false) {
      ctx.beginPath();
      ctx.arc(x, y, highlight ? HIGHLIGHT_RADIUS : POINT_RADIUS, 0, Math.PI * 2, true); // Zwikszamy rozmiar przy podwietleniu
      ctx.fillStyle = color;
      ctx.fill();
      ctx.closePath();
    }

    // Event do dodawania magazyn贸w przez u偶ytkownika, przycigane do siatki
    canvas.addEventListener('click', (event) => {
      if (isCanvasLocked) {
        return; // Jeli canvas jest zablokowany, nie obsugujemy kliknicia
      }
      
      //get canvas x and y position
      const rect = canvas.getBoundingClientRect();
      let x = snapToGrid(event.clientX - rect.left);
      let y = snapToGrid(event.clientY - rect.top);
      console.log(`Kliknito na pozycji: x=${x}, y=${y}`);
      
      if (isEraserMode) {
        handleEraser(event); // Obsuga gumki
        return;
      }
    
      if (remainingWarehouses > 0) {
        const rect = canvas.getBoundingClientRect();
        let x = snapToGrid(event.clientX - rect.left);
        let y = snapToGrid(event.clientY - rect.top);
    
        const factoryUnderneath = isOverFactory(x, y); // Sprawdzamy, czy magazyn jest na fabryce
    
        if (factoryUnderneath) {
          // Zmieniamy kolor na zielony, traktujc to jako zo偶ony budynek
          factoryUnderneath.isCombined = true; // Flaga, 偶e fabryka ma magazyn
          drawPoint(factoryUnderneath.x, factoryUnderneath.y, 'green');
        } else {
          // Normalnie dodajemy magazyn, jeli nie na fabryce
          const warehouse = { x, y };
          warehouses.push(warehouse);
          drawPoint(x, y, 'red');
        }
    
        remainingWarehouses--;
        remainingWarehousesSpan.textContent = remainingWarehouses;
        if (remainingWarehouses === 0) {
          Swal.fire ({
            title: 'Udao si!',
            text: 'Wszystkie magazyny zostay dodane. Mo偶esz teraz czy fabryki z magazynami.',
            icon: 'success',
            confirmButtonText: 'Rozpocznij rysowanie linii'
          });
        }
      } else {
        handleLineDrawing(event); // Uruchamianie rysowania linii po klikniciu
      }
    });
    
    
    document.getElementById('eraserButton').addEventListener('click', () => {
      isEraserMode = !isEraserMode; // Przeczanie trybu gumki
      console.log(`Tryb gumki: ${isEraserMode ? 'WCZONY' : 'WYCZONY'}`);
      const eraserButton = document.getElementById('eraserButton');
      if (isEraserMode) {
        eraserButton.classList.add('active'); // Dodajemy klas .active, jeli tryb gumki jest wczony
      } else {
        eraserButton.classList.remove('active'); // Usuwamy klas .active, jeli tryb gumki jest wyczony
      }
    });
    

    function handleEraser(event) {
      console.assert(isEraserMode, 'Funkcja handleEraser() wywoana, gdy tryb gumki nie jest aktywny!');
      if (!isEraserMode) return; // Jeli tryb gumki nie jest aktywny, nic nie r贸bmy
      console.log('Obsuga gumki...');
    
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
    
      // Sprawdzamy, czy kliknito na istniejc lini
      let lineIndex = null;
      lines.forEach((line, index) => {
        const distanceToLine = pointToLineDistance({ x, y }, line.start, line.end);
        if (distanceToLine <= 5) { // Pr贸g 5 pikseli na usunicie
          lineIndex = index;
        }
      });
    
      if (lineIndex !== null) {
        lines.splice(lineIndex, 1); // Usuwamy lini z tablicy lines
        totalLength = lines.reduce((acc, line) => acc + line.distance, 0); // Obliczamy cakowit dugo tras
        drawAllPoints(); // Rysujemy ponownie, aby odwie偶y canvas bez usunitej linii
      }
    }
    
    function pointToLineDistance(point, lineStart, lineEnd) {
      const A = point.x - lineStart.x;
      const B = point.y - lineStart.y;
      const C = lineEnd.x - lineStart.x;
      const D = lineEnd.y - lineStart.y;
    
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = -1;
      if (len_sq !== 0) param = dot / len_sq;
    
      let xx, yy;
    
      if (param < 0) {
        xx = lineStart.x;
        yy = lineStart.y;
      } else if (param > 1) {
        xx = lineEnd.x;
        yy = lineEnd.y;
      } else {
        xx = lineStart.x + param * C;
        yy = lineStart.y + param * D;
      }
    
      const dx = point.x - xx;
      const dy = point.y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    

    // Funkcja znajdowania najbli偶szego punktu (fabryki lub magazynu)
    function findNearestPoint(x, y) {
      const allPoints = factories.concat(warehouses);
      let nearestPoint = null;
      let minDistance = Infinity;

      allPoints.forEach(point => {
        const distance = calculateDistance({ x, y }, point);
        if (distance < minDistance && distance <= CLICK_THRESHOLD) { // Warunek minimalnej odlegoci
          minDistance = distance;
          nearestPoint = point;
        }
      });

      return nearestPoint;
    }

    function handleLineDrawing(event) {
      ctx.strokeStyle = 'black'; // Ustawienie koloru linii na czarny
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const selectedPoint = findNearestPoint(x, y); // Znajdujemy najbli偶szy punkt
    
      if (!selectedPoint) {
        return; // Jeli nie znaleziono punktu w pobli偶u, nic nie robimy
      }
    
      if (!selectedStart) {
        // Jeli nie ma wybranego punktu pocztkowego, wybieramy punkt i podwietlamy go na fioletowo
        selectedStart = selectedPoint;
        drawAllPoints(); // Odtworzenie wszystkich punkt贸w (aby zresetowa podwietlenie innych)
        drawPoint(selectedStart.x, selectedStart.y, '#800080', true); // Podwietlanie na fioletowo
      } else {
        // Jeli u偶ytkownik klikn na ju偶 wybran fabryk, odznacz j
        if (selectedStart === selectedPoint) {
          selectedStart = null;
          drawAllPoints(); // Resetowanie podwietlenia
          return;
        }
    
        // Sprawdzanie, czy linia ju偶 istnieje
        const lineExists = lines.some(line =>
          (line.start === selectedStart && line.end === selectedPoint) ||
          (line.start === selectedPoint && line.end === selectedStart)
        );
    
        if (lineExists) {
          const toastMixin = Swal.mixin({
            toast: true,
            icon: 'warning',
            title: 'Ta linia ju偶 istnieje!',
            position: 'top-right',
            showConfirmButton: false,
            timer: 2000,
            timerProgressBar: true,
            didOpen: (toast) => {
                toast.addEventListener('mouseenter', Swal.stopTimer)
                toast.addEventListener('mouseleave', Swal.resumeTimer)
            }
          });
          toastMixin.fire();
          return; // Przerywamy jeli linia ju偶 istnieje
        }
    
        // Jeli jest ju偶 wybrany punkt pocztkowy, czymy go z wybranym punktem kocowym
        drawLine(selectedStart, selectedPoint);
        const distance = calculateDistance(selectedStart, selectedPoint);
        lines.push({ start: selectedStart, end: selectedPoint, distance });
    
        // Dodajemy odlego do cakowitej odlegoci TYLKO raz
        totalLength += parseFloat(distance);
        console.log(`Cakowita odlego: ${totalLength.toFixed(2)}`);
    
        drawDistanceLabel(selectedStart, selectedPoint, distance);
        selectedStart = null; // Resetowanie punktu pocztkowego po narysowaniu linii
        drawAllPoints(); // Resetowanie podwietlenia
      }
    }
    

    // Rysowanie wszystkich punkt贸w (fabryki i magazyny) bez podwietlenia
    function drawAllPoints() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Czycimy canvas przed odrysowaniem wszystkich element贸w
      drawGrid(); // Rysowanie siatki
    
      // Rysujemy wszystkie fabryki
      factories.forEach(factory => {
        const color = factory.isCombined ? 'green' : 'blue'; // Zmieniamy kolor, jeli fabryka ma magazyn
        drawPoint(factory.x, factory.y, color);
      });
    
      // Rysujemy wszystkie magazyny, kt贸re nie s na fabrykach
      warehouses.forEach(warehouse => {
        drawPoint(warehouse.x, warehouse.y, 'red');
      });
    
      // Rysujemy wszystkie linie
      lines.forEach(line => {
        drawLine(line.start, line.end); // Odtwarzamy narysowane linie
        drawDistanceLabel(line.start, line.end, line.distance); // Odtwarzamy wywietlanie odlegoci nad liniami
      });
    }
    

    function checkConnections() {
      const allPoints = factories.concat(warehouses); // Wszystkie punkty (fabryki i magazyny)
      const connectedPoints = new Set(); // Zbi贸r punkt贸w, kt贸re s poczone
    
      // Przechodzimy przez wszystkie poczenia w tablicy lines
      lines.forEach(line => {
        connectedPoints.add(line.start); // Dodajemy punkt startowy
        connectedPoints.add(line.end);   // Dodajemy punkt kocowy
      });
    
      // Sprawdzamy, czy ka偶dy punkt (fabryka lub magazyn) ma poczenie
      for (let point of allPoints) {
        // Jeli punkt jest poczony z magazynem, traktujemy go jako poczony (fabryka + magazyn)
        if (point.isCombined) continue;
    
        if (!connectedPoints.has(point)) {
          return false; // Jeli znajdziemy punkt bez poczenia, zwracamy false
        }
      }
    
      return true; // Jeli ka偶dy punkt ma poczenie, zwracamy true
    }
    
    // Number of vertices in the graph 
    const V = 11;
    const possiblePlacements = 651 - 3;
    function getEdgePoints(parent, allBuildings) {
      let EdgePoints = [];
      for (let i = V - 1; i > 0; ++i) {
        let point1 = {x: allBuildings[parent[i]].x, y: allBuildings[parent[i]].y};
        let point2 = {x: allBuildings[i].x,         y: allBuildings[i].y};
        EdgePoints.concat({p1: point1, p2: point1});
      }
      return EdgePoints;
    }
    // daj na wejsciu all fabryki, 


/*
i 0 ,0  0 ,0 ... 0  ,0  0  ,0
j 20,0  20,0 ... 20 ,0  20 ,0
k 40,0  40,0 ... 40 ,0  40 ,0
l 60,0  80,0 ... 600,0  0  ,20
*/

    function startAlgorithm() {
      let theBestWarehouseConfiguration = [];
      let theBestMatirxOfDistances = [];
      let theBestConnections = [];
      let theShortestDistance = Infinity;
      let yi = 0;
      let yj = 0;
      let yk = 0;
      let yl = 0;

      //z logicznego punktu widzenia, te petle sa nie fajne, bo i,j,k,l odpowiadaja za koordynaty, co wplywa na zakres petli
      for (let i = 0; i < possiblePlacements; i++) {
        let xi = (i*20)%620;
        if (xi == 0 && i > 0) yi++;
        const point1 = {x: xi, y: yi*20};
        console.log(`IIIIIIIIIIII ${i}`);
        // console.log(point1);

        let possibleJPlacements = possiblePlacements - i;
        for (let j = i + 1; j < possibleJPlacements; j++) {
          let xj = (j*20)%620;
          if (xj == 0 && j > 0) yj++;
          const point2 = {x: xj, y: yj*20};
          // console.log(point2);
          console.log(`JJJJ ${j}`);

          let possibleKPlacements = possiblePlacements - (j - i + 1);
          for (let k = j + 1; k < possibleKPlacements; k++) {
            let xk = (k*20)%620;
            if (xk == 0 && k > 0) yk++;
            const point3 = {x: xk, y: yk*20};
            // console.log(point3);
            // console.log(`K ${k}`);

            let possibleLPlacements = possiblePlacements - (k - j + 1);
            for (let l = k + 1; l < possibleLPlacements; l++) {
              let xl = (l*20)%620;
              if (xl == 0 && l > 0) yl++;
              const point4 = {x: xl, y: yl*20};
              // console.log(point4);

              const warehouseConfiguration = [ //all axis x20, xmod 600, ymod 400
                point1,
                point2,
                point3,
                point4
              ];
              
              const allBuildings = factories.concat(warehouseConfiguration); //tu razem factories i warehouses
              // console.log('allBuildings');
              // console.log(allBuildings);
              let matirxOfDistances = [[],[],[],[],[],[],[],[],[],[],[]]; //matrix size 11x11 with all distances, diagonal is 0
              for (let ii = 0; ii < V; ii++) {
                for (let jj = 0; jj < V; jj++) {
                  matirxOfDistances[ii][jj] = calculateDistance(allBuildings[ii],allBuildings[jj]);
                }
              }
              let primMSTres = primMST(matirxOfDistances);
              let currentDistance = primMSTres[0];
              let connections = primMSTres[1];
              // console.log(`currentDistance ${currentDistance}`);
              // console.log(`theShortestDistance ${theShortestDistance}`);

              if (currentDistance < theShortestDistance) {
                console.log(`currentBESTDistance ${currentDistance}`);
                theBestWarehouseConfiguration = warehouseConfiguration;
                theBestMatirxOfDistances = matirxOfDistances;
                theBestConnections = connections;
                theShortestDistance = currentDistance;
              }
            }
          }
        }
      }
      theBestWarehouseConfiguration = theBestWarehouseConfiguration.concat(factories);
      console.log(`theBestWarehouseConfiguration ${theBestWarehouseConfiguration}`);
      console.log(`theBestConnections ${theBestConnections}`);

      const EdgePoints = getEdgePoints(theBestConnections, theBestWarehouseConfiguration);
      return [EdgePoints, theBestWarehouseConfiguration];
    }


    // A utility function to find the vertex with 
    // minimum key value, from the set of vertices 
    // not yet included in MST 
    function minKey(key, mstSet) 
    { 
      // Initialize min value 
      let min = Number.MAX_VALUE, min_index; 

      for (let v = 0; v < V; v++) 
        if (mstSet[v] == false && key[v] < min) 
          min = key[v], min_index = v; 

      return min_index; 
    } 

    function calculateTotalDistance(parent, graph){
      let totalDistance = 0;
      for (let i = V - 1; i > 0; --i) 
        totalDistance += graph[parent[i]][i];
      return totalDistance;
    }

    // Function to construct and print MST for 
    // a graph represented using adjacency 
    // matrix representation 
    function primMST(graph) 
    { 
      // Array to store constructed MST 
      let parent = []; 
      
      // Key values used to pick minimum weight edge in cut 
      let key = []; 
      
      // To represent set of vertices included in MST 
      let mstSet = []; 

      // Initialize all keys as INFINITE 
      for (let i = 0; i < V; i++) 
        key[i] = Number.MAX_VALUE, mstSet[i] = false; 

      // Always include first 1st vertex in MST. 
      // Make key 0 so that this vertex is picked as first vertex. 
      key[0] = 0; 
      parent[0] = -1; // First node is always root of MST 

      // The MST will have V vertices 
      for (let count = 0; count < V - 1; count++)
      { 
        // Pick the minimum key vertex from the 
        // set of vertices not yet included in MST 
        let u = minKey(key, mstSet); 

        // Add the picked vertex to the MST Set 
        mstSet[u] = true; 

        // Update key value and parent index of 
        // the adjacent vertices of the picked vertex. 
        // Consider only those vertices which are not 
        // yet included in MST 
        for (let v = 0; v < V; v++) 
          // graph[u][v] is non zero only for adjacent vertices of m 
          // mstSet[v] is false for vertices not yet included in MST 
          // Update the key only if graph[u][v] is smaller than key[v] 
          if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) 
            parent[v] = u, key[v] = graph[u][v]; 

      } 

      // console.log(`parent ${parent}`);
      // console.log(`graph ${graph}`);
      // console.log(`calculateTotalDistance(parent, graph) ${calculateTotalDistance(parent, graph)}`);

      return [calculateTotalDistance(parent, graph), parent];
    } 

    // Rysowanie linii
    function drawLine(start, end) {
      ctx.strokeStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
    }

    // Obliczanie odlegoci pomidzy punktami
    function calculateDistance(point1, point2) {
      const dx = point1.x - point2.x;
      const dy = point1.y - point2.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      return Math.round(distance);
    }

    // Wywietlanie odlegoci nad lini
    function drawDistanceLabel(start, end, distance) {
      const midX = (start.x + end.x) / 2;
      const midY = (start.y + end.y) / 2;
      ctx.font = '12px Arial';
      ctx.fillStyle = 'black';
      ctx.fillText(`${distance}`, midX, midY);
    }

    function startTimer(duration) {
      const timerBar = document.getElementById('timer');
      timeRemaining = duration;
    
      timerInterval = setInterval(() => {
        timeRemaining--;
        const percentage = (timeRemaining / duration) * 100;
        timerBar.style.width = `${percentage}%`;
    
        if (timeRemaining <= 0) {
          clearInterval(timerInterval);
          isCanvasLocked = true; // Blokujemy interakcje z canvasem
          Swal.fire({
            title: 'Koniec czasu!',
            text: 'Czas min. Mo偶esz teraz zobaczy wyniki.',
            icon: 'info',
            confirmButtonText: 'Zobacz wyniki'
          }).then(() => {
            console.log("wyniki");
          });
        }
      }, 1000);
    }
    

    document.getElementById('endGameButton').addEventListener('click', () => {
      // Sprawdzamy, czy wszystkie punkty maj poczenie
      if (!checkConnections()) {
        Swal.fire({
          title: 'Chwila!',
          text: 'Nie wszystkie punkty na mapie s poczone! Upewnij si, 偶e ka偶da fabryka i magazyn ma co najmniej jedno poczenie.',
          icon: 'warning',
          confirmButtonText: 'OK'
        });
        return; // Przerywamy, jeli punkty nie s poczone
      }
    
      Swal.fire({
        title: 'Czy na pewno chcesz zakoczy gr?',
        text: "Zakoczenie gry spowoduje zapisanie wynik贸w.",
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'Tak, zakocz',
        cancelButtonText: 'Nie, kontynuuj',
      }).then((result) => {
        if (result.isConfirmed) {
          clearInterval(timerInterval); // Zatrzymanie timera
          isCanvasLocked = true; // Blokowanie canvasu
    
          const timeElapsed = 180 - timeRemaining; // Obliczenie czasu, kt贸ry upyn
          Swal.fire({
            title: 'Gra zakoczona!',
            text: `Upyno: ${Math.round(timeElapsed)} sekund.\nCakowita dugo tras: ${Math.round(totalLength)}.`,
            icon: 'success',
            confirmButtonText: 'OK'
          }).then(() => {
            console.log(`Czas: ${Math.round(timeElapsed)} sekund`);
            console.log(`Cakowita dugo tras: ${Math.round(totalLength)} jednostek`);
          }).then(() => {
            // Wysyamy wyniki do serwera
            let formData = new FormData();
            formData.append('username', username);
            formData.append('index', index);
            formData.append('time', timeElapsed);
            formData.append('distance', totalLength);
            console.log(formData);
            return fetch('/backend/api/saveResults.php', {
              method: 'POST',
              body: formData
            })
            .then(response => {
              return response.json().then(data => {
                if (data.code !== 200) {
                  throw new Error(data.error);
                }
              });
            })
            .catch(error => {
              Swal.fire({
                title: 'Bd!',
                text: `${error.message}`,
                icon: 'error',
                confirmButtonText: 'OK'
              });
            });
          });
        }
      });
    });
    
    
    // Uruchomienie gry
    generateFactories(7); // Generowanie fabryk, np. 7

  </script>
</body>
</html>
